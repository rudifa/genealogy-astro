---
import type {GenealogyData} from "@/types";

interface Props {
  data: GenealogyData;
}

const {data} = Astro.props;
---

<div class='genealogy-graph'>
  <!-- This container will be populated by the client-side script -->
</div>

<style>
  .genealogy-graph {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
  }
  .genealogy-graph svg {
    max-width: 100%;
    height: auto;
  }
</style>

<script type='module' define:vars={{genealogyData: data}}>
  // --- Load Graphviz from the CDN ---
  import {Graphviz} from "https://cdn.jsdelivr.net/npm/@hpcc-js/wasm@2.13.0/dist/index.js";

  // We need to explicitly load the WASM file
  const graphvizPromise = Graphviz.load();

  // --- genealogyData-to-svg functions  ---
  function genealogyDotString(data) {
    const dotLines = [
      "strict digraph G {",
      '  node [shape=box, style="filled", fillcolor="#E9F4FF"];',
      "  edge [dir=none];",
    ];

    // 1. Collect all unique names from the dataset to define nodes.
    const allNames = new Set();
    data.persons.forEach((p) => {
      allNames.add(p.name);
      if (p.mother) allNames.add(p.mother);
      if (p.father) allNames.add(p.father);
    });

    // 2. Define all person nodes. Make them clickable only if they have a main entry.
    allNames.forEach((name) => {
      const personHasEntry = data.persons.some((p) => p.name === name);
      const url = personHasEntry
        ? `URL="person:${encodeURIComponent(name)}"`
        : "";
      dotLines.push(`  "${name}" [label="${name}"${url ? ", " + url : ""}];`);
    });

    // 3. Define all relationships.
    for (const person of data.persons) {
      const childNode = `"${person.name}"`;
      if (person.mother && person.father) {
        // Use a more robust ID for the invisible parents node
        const parentsNode = `"${person.mother}_${person.father}_family"`;
        dotLines.push(
          `  ${parentsNode} [shape=point];`,
          `  "${person.mother}" -> ${parentsNode};`,
          `  "${person.father}" -> ${parentsNode};`,
          `  ${parentsNode} -> ${childNode} [dir=forward, arrowhead=normal];`
        );
      } else if (person.mother) {
        dotLines.push(
          `  "${person.mother}" -> ${childNode} [dir=forward, arrowhead=normal];`
        );
      } else if (person.father) {
        dotLines.push(
          `  "${person.father}" -> ${childNode} [dir=forward, arrowhead=normal];`
        );
      }
    }

    dotLines.push("}");
    return dotLines.join("\n");
  }

  async function genealogySvgString(data) {
    const dotString = genealogyDotString(data);

    try {
      const graphviz = await graphvizPromise;
      return graphviz.layout(dotString, "svg", "dot");
    } catch (error) {
      console.error("Error rendering graph:", error);
      return `<p>Error rendering graph: ${error.message}</p>`;
    }
  }

  // --- Initialize the graph and dialog function ---
  async function initializeGraph() {
    // --- Get references to dialog elements ---
    const dialog = document.getElementById("edit-dialog");
    const form = document.getElementById("edit-form");
    const originalNameInput = document.getElementById("original-name");
    const nameInput = document.getElementById("person-name");
    const motherInput = document.getElementById("person-mother");
    const fatherInput = document.getElementById("person-father");
    const saveButton = document.getElementById("save-button");
    const cancelButton = document.getElementById("cancel-button");
    const removeButton = document.getElementById("remove-button");

    // --- Graph click handler ---
    const graphContainer = document.querySelector(".genealogy-graph");

    // --- Render the graph on page load ---
    if (graphContainer) {
      const svgString = await genealogySvgString(genealogyData);
      graphContainer.innerHTML = svgString;
    }

    if (graphContainer) {
      // --- Add click event listener to the graph container ---
      graphContainer.addEventListener("click", (event) => {
        // Find the nearest <a> tag ancestor of the clicked element.
        // Graphviz wraps clickable nodes in <a> tags.
        const targetLink = event.target.closest("a");

        if (!targetLink) {
          return;
        }

        // Check for our custom URL scheme. Graphviz uses `xlink:href` for SVGs.
        const url =
          targetLink.getAttribute("xlink:href") ||
          targetLink.getAttribute("href");

        if (url && url.startsWith("person:")) {
          // Prevent the browser from trying to navigate to the fragment.
          event.preventDefault();

          // Extract the person's name from the URL.
          const personName = decodeURIComponent(
            url.substring("person:".length)
          );

          // Find the person's data and open the dialog
          const personData = genealogyData.persons.find(
            (p) => p.name === personName
          );
          if (personData) {
            openEditDialog(personData);
          }
        }
      });
    }

    // --- Dialog functions ---
    function openEditDialog(person) {
      originalNameInput.value = person.name;
      nameInput.value = person.name;
      motherInput.value = person.mother || "";
      fatherInput.value = person.father || "";
      dialog.style.display = "flex";
    }

    function closeEditDialog() {
      dialog.style.display = "none";
    }

    // --- Dialog event listeners ---
    cancelButton.addEventListener("click", closeEditDialog);

    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const updatedPerson = {
        originalName: originalNameInput.value,
        name: nameInput.value,
        mother: motherInput.value || null,
        father: fatherInput.value || null,
      };

      // Find the person in the data array by their original name and update or add them.
      // This is a key step for enabling dynamic graph updates without a page reload.
      const personIndex = genealogyData.persons.findIndex(
        (p) => p.name === updatedPerson.originalName
      );

      const newPersonData = {
        name: updatedPerson.name,
        mother: updatedPerson.mother,
        father: updatedPerson.father,
      };

      if (personIndex > -1) {
        // Update the existing person's data in the array.
        genealogyData.persons[personIndex] = newPersonData;

        // If the name was changed, we must update all references to this person.
        if (newPersonData.name !== updatedPerson.originalName) {
          genealogyData.persons.forEach((p) => {
            if (p.mother === updatedPerson.originalName) {
              p.mother = newPersonData.name;
            }
            if (p.father === updatedPerson.originalName) {
              p.father = newPersonData.name;
            }
          });
        }
      } else {
        // If the person wasn't found, add them as a new entry.
        genealogyData.persons.push(newPersonData);
      }

      console.log("Updated data:", genealogyData);

      // Re-render the graph with the updated data
      if (graphContainer) {
        const newSvgString = await genealogySvgString(genealogyData);
        graphContainer.innerHTML = newSvgString;
        console.log("Updated svg:", newSvgString);
      }

      closeEditDialog();
    });

    removeButton.addEventListener("click", () => {
      const personName = originalNameInput.value;
      if (confirm(`Are you sure you want to remove ${personName}?`)) {
        console.log("Deleting person:", personName);
        // In a real app, you would send this to a server and then refresh the page or graph.
        alert(
          `${personName} removed. Refresh the page to see changes (not implemented).`
        );
        closeEditDialog();
      }
    });
  }
  // Initialize the graph when the DOM is ready
  document.addEventListener("DOMContentLoaded", initializeGraph);
</script>
