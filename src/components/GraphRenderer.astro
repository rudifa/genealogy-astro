---
import type {Language, Translations} from "../i18n/index";

interface Props {
  language: Language;
  translations: Translations;
}

const {language, translations} = Astro.props;
---

<div class='genealogy-graph'>
  <!-- Zoom controls -->
  <div class='zoom-controls'>
    <button id='zoom-in' class='zoom-btn' title='Zoom In'>+</button>
    <button id='zoom-out' class='zoom-btn' title='Zoom Out'>−</button>
    <button id='zoom-fit' class='zoom-btn' title='Fit to Screen'>⌶</button>
    <button id='zoom-reset' class='zoom-btn' title='Reset Zoom'>⌂</button>
  </div>

  <!-- SVG container with zoom/pan support -->
  <div id='graph-container' class='graph-container'>
    <div id='graph-placeholder' class='graph-placeholder'>
      <p>{translations.loadingGraph}</p>
    </div>
  </div>
</div>

<style>
  .genealogy-graph {
    flex: 1;
    display: flex;
    flex-direction: column;
    position: relative;
    background-color: #fafafa;
    overflow: hidden;
  }

  .zoom-controls {
    position: absolute;
    top: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 5px;
    z-index: 100;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    padding: 8px;
  }

  .zoom-btn {
    width: 36px;
    height: 36px;
    border: none;
    background: white;
    border-radius: 6px;
    font-size: 18px;
    font-weight: bold;
    color: #495057;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    user-select: none;
  }

  .zoom-btn:hover {
    background-color: #007acc;
    color: white;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }

  .zoom-btn:active {
    transform: translateY(0);
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  }

  .graph-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    cursor: grab;
  }

  .graph-container.panning {
    cursor: grabbing;
  }

  .graph-content {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
    transition: transform 0.2s ease;
  }

  .graph-content.smooth-transition {
    transition: transform 0.3s ease;
  }

  .graph-placeholder {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: #6c757d;
    font-style: italic;
  }

  .graph-placeholder p {
    margin: 0;
    font-size: 16px;
  }

  /* SVG styling for better interaction */
  .graph-content svg {
    display: block;
    max-width: none;
    max-height: none;
  }

  /* Responsive zoom controls */
  @media (max-width: 768px) {
    .zoom-controls {
      top: 10px;
      right: 10px;
      padding: 6px;
    }

    .zoom-btn {
      width: 32px;
      height: 32px;
      font-size: 16px;
    }
  }
</style>

<script is:inline define:vars={{translations}}>
  // Graph Renderer functionality
  function initializeGraphRenderer() {
    console.log("GraphRenderer: Starting initialization");

    // Prevent multiple initializations with a single flag
    if (window.graphRendererInitialized) {
      console.log("GraphRenderer: Already initialized, skipping");
      return;
    }
    window.graphRendererInitialized = true;

    // Store current translations (will be updated by language changes)
    let currentTranslations = translations;

    // DOM elements are available immediately since they're in the same component
    const graphContainer = document.getElementById("graph-container");
    const graphPlaceholder = document.getElementById("graph-placeholder");
    const zoomInBtn = document.getElementById("zoom-in");
    const zoomOutBtn = document.getElementById("zoom-out");
    const zoomFitBtn = document.getElementById("zoom-fit");
    const zoomResetBtn = document.getElementById("zoom-reset");

    if (!graphContainer || !graphPlaceholder) {
      console.error("GraphRenderer: DOM elements not found in component");
      return;
    }

    console.log("GraphRenderer: DOM elements found, setting up functionality");

    // Update graph renderer translations
    function updateGraphRendererTranslations(newTranslations) {
      currentTranslations = newTranslations;

      // Update graph placeholder text
      const graphPlaceholder = document.querySelector("#graph-placeholder p");
      if (graphPlaceholder)
        graphPlaceholder.textContent = currentTranslations.loadingGraph;
    }

    // Listen for language changes
    window.addEventListener("languageChanged", function (event) {
      console.log("GraphRenderer: Language changed to", event.detail.language);
      updateGraphRendererTranslations(event.detail.translations);
    });

    // Initialize graph renderer events and rendering
    function setupGraphFunctionality() {
      console.log("GraphRenderer: Setting up graph functionality");

      // Zoom and pan state
      let currentScale = 1;
      let currentTranslateX = 0;
      let currentTranslateY = 0;
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragStartTranslateX = 0;
      let dragStartTranslateY = 0;
      let graphContent = null;
      let svgElement = null;

      // Zoom configuration
      const MIN_SCALE = 0.1;
      const MAX_SCALE = 5;
      const ZOOM_FACTOR = 1.2;

      // Update transform with current scale and translate values
      function updateTransform(smooth = false) {
        if (!graphContent) return;

        if (smooth) {
          graphContent.classList.add("smooth-transition");
          setTimeout(() => {
            if (graphContent)
              graphContent.classList.remove("smooth-transition");
          }, 300);
        }

        console.log(
          `GraphRenderer: updateTransform - scale: ${currentScale.toFixed(3)}, translate: (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)}), smooth: ${smooth}`
        );
        graphContent.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentScale})`;
      }

      // Zoom to a specific scale at a given point
      function zoomToPoint(newScale, clientX, clientY) {
        if (!graphContent || !svgElement) return;

        const oldScale = currentScale;
        const oldTranslateX = currentTranslateX;
        const oldTranslateY = currentTranslateY;

        newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

        const rect = graphContainer.getBoundingClientRect();
        const offsetX = clientX - rect.left;
        const offsetY = clientY - rect.top;

        // Calculate the point in the current coordinate system
        const currentPointX = (offsetX - currentTranslateX) / currentScale;
        const currentPointY = (offsetY - currentTranslateY) / currentScale;

        // Update scale
        currentScale = newScale;

        // Calculate new translate to keep the same point under the cursor
        currentTranslateX = offsetX - currentPointX * currentScale;
        currentTranslateY = offsetY - currentPointY * currentScale;

        console.log(
          `GraphRenderer: zoomToPoint - from scale: ${oldScale.toFixed(3)} to ${currentScale.toFixed(3)}, translate: (${oldTranslateX.toFixed(1)}, ${oldTranslateY.toFixed(1)}) to (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)}), cursor: (${clientX}, ${clientY})`
        );
        updateTransform();
      }

      // Fit the SVG to the container
      function fitToContainer() {
        if (!graphContent || !svgElement) return;

        const containerRect = graphContainer.getBoundingClientRect();

        // Handle case where container is not visible yet
        if (containerRect.width === 0 || containerRect.height === 0) {
          console.log(
            `GraphRenderer: fitToContainer - container not visible (${containerRect.width}x${containerRect.height}), retrying...`
          );
          setTimeout(() => fitToContainer(), 100);
          return;
        }

        const svgRect = svgElement.getBBox();

        if (svgRect.width === 0 || svgRect.height === 0) {
          console.log(
            `GraphRenderer: fitToContainer - SVG not ready (${svgRect.width}x${svgRect.height}), skipping`
          );
          return;
        }

        const oldScale = currentScale;
        const oldTranslateX = currentTranslateX;
        const oldTranslateY = currentTranslateY;

        // Use actual rendered size if available (when SVG has auto-sized after removing width/height)
        let svgWidth, svgHeight;
        if (svgElement.clientWidth > 0 && svgElement.clientHeight > 0) {
          // SVG has been auto-sized, use the rendered dimensions
          svgWidth = svgElement.clientWidth;
          svgHeight = svgElement.clientHeight;
        } else {
          // Fallback to getBBox logical dimensions
          svgWidth = svgRect.width;
          svgHeight = svgRect.height;
        }

        // Add more padding to ensure content doesn't touch edges
        const padding = 60; // Increased padding for better visual spacing
        const scaleX = (containerRect.width - padding) / svgWidth;
        const scaleY = (containerRect.height - padding) / svgHeight;

        // Always fit to container, but don't zoom in beyond 100%
        currentScale = Math.min(scaleX, scaleY, 1);

        // Center the content in the available space
        currentTranslateX = (containerRect.width - svgWidth * currentScale) / 2;
        currentTranslateY =
          (containerRect.height - svgHeight * currentScale) / 2;

        console.log(
          `GraphRenderer: fitToContainer - container: ${containerRect.width.toFixed(0)}x${containerRect.height.toFixed(0)}, SVG getBBox: ${svgRect.width.toFixed(0)}x${svgRect.height.toFixed(0)}, SVG client: ${svgElement.clientWidth}x${svgElement.clientHeight}, using: ${svgWidth.toFixed(0)}x${svgHeight.toFixed(0)}, scaleX: ${scaleX.toFixed(3)}, scaleY: ${scaleY.toFixed(3)}, scale: ${oldScale.toFixed(3)} to ${currentScale.toFixed(3)}, translate: (${oldTranslateX.toFixed(1)}, ${oldTranslateY.toFixed(1)}) to (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)})`
        );
        updateTransform(true);
      }

      // Reset zoom and position
      function resetZoom() {
        const oldScale = currentScale;
        const oldTranslateX = currentTranslateX;
        const oldTranslateY = currentTranslateY;

        currentScale = 1;
        currentTranslateX = 0;
        currentTranslateY = 0;

        console.log(
          `GraphRenderer: resetZoom - scale: ${oldScale.toFixed(3)} to ${currentScale.toFixed(3)}, translate: (${oldTranslateX.toFixed(1)}, ${oldTranslateY.toFixed(1)}) to (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)})`
        );
        updateTransform(true);
      }

      // Set up zoom controls
      if (zoomInBtn) {
        zoomInBtn.addEventListener("click", () => {
          const rect = graphContainer.getBoundingClientRect();
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          zoomToPoint(currentScale * ZOOM_FACTOR, centerX, centerY);
        });
      }

      if (zoomOutBtn) {
        zoomOutBtn.addEventListener("click", () => {
          const rect = graphContainer.getBoundingClientRect();
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          zoomToPoint(currentScale / ZOOM_FACTOR, centerX, centerY);
        });
      }

      if (zoomFitBtn) {
        zoomFitBtn.addEventListener("click", fitToContainer);
      }

      if (zoomResetBtn) {
        zoomResetBtn.addEventListener("click", resetZoom);
      }

      // Mouse wheel zoom
      graphContainer.addEventListener("wheel", (event) => {
        event.preventDefault();

        const zoomIn = event.deltaY < 0;
        const newScale = zoomIn
          ? currentScale * ZOOM_FACTOR
          : currentScale / ZOOM_FACTOR;

        zoomToPoint(
          newScale,
          event.clientX - graphContainer.getBoundingClientRect().left,
          event.clientY - graphContainer.getBoundingClientRect().top
        );
      });

      // Mouse drag panning
      graphContainer.addEventListener("mousedown", (event) => {
        if (event.button !== 0) return; // Only left mouse button

        isDragging = true;
        dragStartX = event.clientX;
        dragStartY = event.clientY;
        dragStartTranslateX = currentTranslateX;
        dragStartTranslateY = currentTranslateY;

        graphContainer.classList.add("panning");
        event.preventDefault();
      });

      document.addEventListener("mousemove", (event) => {
        if (!isDragging) return;

        const deltaX = event.clientX - dragStartX;
        const deltaY = event.clientY - dragStartY;

        const oldTranslateX = currentTranslateX;
        const oldTranslateY = currentTranslateY;

        currentTranslateX = dragStartTranslateX + deltaX;
        currentTranslateY = dragStartTranslateY + deltaY;

        // Only log every 10px of movement to avoid spam
        if (Math.abs(deltaX) % 10 < 2 && Math.abs(deltaY) % 10 < 2) {
          console.log(
            `GraphRenderer: mouseDrag - delta: (${deltaX.toFixed(0)}, ${deltaY.toFixed(0)}), translate: (${oldTranslateX.toFixed(1)}, ${oldTranslateY.toFixed(1)}) to (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)})`
          );
        }

        updateTransform();
      });

      document.addEventListener("mouseup", () => {
        if (isDragging) {
          isDragging = false;
          graphContainer.classList.remove("panning");
        }
      });

      // Window resize handler to maintain proper fit
      let resizeTimeout;
      function handleResize() {
        // Debounce resize events to avoid excessive calls
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if (graphContent && svgElement) {
            console.log(
              `GraphRenderer: handleResize - triggering fitToContainer`
            );
            // Re-fit the graph to the new container size
            fitToContainer();
          }
        }, 150);
      }

      // Listen for window resize events
      window.addEventListener("resize", handleResize);

      // Store cleanup function for this component instance
      window.graphRendererCleanup = function () {
        window.removeEventListener("resize", handleResize);
        clearTimeout(resizeTimeout);
      };

      // Touch support for mobile
      let touchStartDistance = 0;
      let touchStartScale = 1;

      graphContainer.addEventListener("touchstart", (event) => {
        if (event.touches.length === 2) {
          // Two finger pinch
          const touch1 = event.touches[0];
          const touch2 = event.touches[1];
          touchStartDistance = Math.hypot(
            touch1.clientX - touch2.clientX,
            touch1.clientY - touch2.clientY
          );
          touchStartScale = currentScale;
          event.preventDefault();
        } else if (event.touches.length === 1) {
          // Single finger drag
          const touch = event.touches[0];
          isDragging = true;
          dragStartX = touch.clientX;
          dragStartY = touch.clientY;
          dragStartTranslateX = currentTranslateX;
          dragStartTranslateY = currentTranslateY;
          event.preventDefault();
        }
      });

      graphContainer.addEventListener("touchmove", (event) => {
        if (event.touches.length === 2) {
          // Two finger pinch zoom
          const touch1 = event.touches[0];
          const touch2 = event.touches[1];
          const currentDistance = Math.hypot(
            touch1.clientX - touch2.clientX,
            touch1.clientY - touch2.clientY
          );

          if (touchStartDistance > 0) {
            const scaleFactor = currentDistance / touchStartDistance;
            const newScale = touchStartScale * scaleFactor;

            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;
            const rect = graphContainer.getBoundingClientRect();

            zoomToPoint(newScale, centerX - rect.left, centerY - rect.top);
          }
          event.preventDefault();
        } else if (event.touches.length === 1 && isDragging) {
          // Single finger pan
          const touch = event.touches[0];
          const deltaX = touch.clientX - dragStartX;
          const deltaY = touch.clientY - dragStartY;

          currentTranslateX = dragStartTranslateX + deltaX;
          currentTranslateY = dragStartTranslateY + deltaY;

          updateTransform();
          event.preventDefault();
        }
      });

      graphContainer.addEventListener("touchend", () => {
        isDragging = false;
        touchStartDistance = 0;
      });

      // --- Function to render the graph ---
      async function renderGraph() {
        const genealogyData = window.genealogyData;
        const genealogySvgString = window.genealogySvgString;
        const showNotification = window.showNotification;
        const setLoadingState = window.setLoadingState;
        const isRendering = window.genealogyIsRendering;

        console.log("GraphRenderer: renderGraph called");
        console.log("GraphRenderer: genealogyData:", genealogyData);
        console.log(
          "GraphRenderer: persons count:",
          genealogyData?.persons?.length
        );

        if (
          !graphContainer ||
          isRendering ||
          !genealogyData ||
          !genealogySvgString
        ) {
          console.warn("GraphRenderer: Missing dependencies for rendering");
          console.warn("GraphRenderer: graphContainer:", !!graphContainer);
          console.warn("GraphRenderer: isRendering:", isRendering);
          console.warn("GraphRenderer: genealogyData:", !!genealogyData);
          console.warn(
            "GraphRenderer: genealogySvgString:",
            !!genealogySvgString
          );
          return;
        }

        try {
          if (setLoadingState) setLoadingState(true);
          window.genealogyIsRendering = true;

          // Hide placeholder if it exists
          if (graphPlaceholder) {
            graphPlaceholder.style.display = "none";
          }

          console.log(
            "GraphRenderer: Calling genealogySvgString with data:",
            genealogyData
          );
          const newSvgString = await genealogySvgString(genealogyData);
          console.log(
            "GraphRenderer: Received SVG string length:",
            newSvgString?.length
          );

          // Create or update graph content container
          if (!graphContent) {
            graphContent = document.createElement("div");
            graphContent.className = "graph-content";
            graphContainer.appendChild(graphContent);
          }

          graphContent.innerHTML = newSvgString;

          // Get reference to the SVG element
          svgElement = graphContent.querySelector("svg");
          if (svgElement) {
            // Log SVG attributes before modification
            console.log("GraphRenderer: SVG before modification:", {
              width: svgElement.getAttribute("width"),
              height: svgElement.getAttribute("height"),
              viewBox: svgElement.getAttribute("viewBox"),
              style: svgElement.getAttribute("style"),
            });

            // Instead of removing width/height, preserve the original size
            // and let CSS handle the scaling
            const originalWidth = svgElement.getAttribute("width");
            const originalHeight = svgElement.getAttribute("height");

            // Convert pt to px properly (1pt = 4/3 px)
            if (originalWidth && originalHeight) {
              const widthValue = parseFloat(originalWidth);
              const heightValue = parseFloat(originalHeight);

              // Convert pt to px: 1pt = 4/3 px
              const widthPx = Math.round((widthValue * 4) / 3);
              const heightPx = Math.round((heightValue * 4) / 3);

              // Set explicit pixel dimensions
              svgElement.style.width = widthPx + "px";
              svgElement.style.height = heightPx + "px";

              console.log(
                `GraphRenderer: Converted SVG size from ${widthValue}pt x ${heightValue}pt to ${widthPx}px x ${heightPx}px`
              );

              // Remove the pt-based attributes to avoid conflicts
              svgElement.removeAttribute("width");
              svgElement.removeAttribute("height");
            }

            // Log SVG attributes after modification
            console.log("GraphRenderer: SVG after modification:", {
              getBBox: svgElement.getBBox(),
              clientWidth: svgElement.clientWidth,
              clientHeight: svgElement.clientHeight,
              offsetWidth: svgElement.offsetWidth,
              offsetHeight: svgElement.offsetHeight,
              styleWidth: svgElement.style.width,
              styleHeight: svgElement.style.height,
            });

            // Auto-fit to container on first render or when tree changes
            setTimeout(() => {
              fitToContainer();
            }, 100);
          }

          // Show success notification for significant changes
          if (genealogyData.persons.length === 0 && showNotification) {
            showNotification(
              currentTranslations.graphCleared || "Graph cleared",
              "info"
            );
          }

          console.log("GraphRenderer: Graph rendered successfully");
        } catch (error) {
          console.error("GraphRenderer: Error rendering graph:", error);
          if (graphPlaceholder) {
            graphPlaceholder.style.display = "block";
            const p = graphPlaceholder.querySelector("p");
            if (p) {
              p.textContent =
                currentTranslations.renderError ||
                "Error rendering graph. Please try again.";
              p.style.color = "#dc3545";
            }
          }
        } finally {
          window.genealogyIsRendering = false;
          if (setLoadingState) setLoadingState(false);
        }
      }

      // --- Graph interaction handler ---
      function handleGraphClick(event) {
        try {
          const targetLink = event.target.closest("a");

          if (!targetLink) {
            return;
          }

          const url =
            targetLink.getAttribute("xlink:href") ||
            targetLink.getAttribute("href");

          if (url && url.startsWith("person:")) {
            event.preventDefault();

            const personName = decodeURIComponent(
              url.substring("person:".length)
            );

            console.log("GraphRenderer: Person clicked:", personName);

            const genealogyData = window.genealogyData;
            if (!genealogyData) {
              console.warn("GraphRenderer: No genealogy data available");
              return;
            }

            const personData = genealogyData.persons.find(
              (p) => p.name === personName
            );

            if (personData) {
              // Use the current openEditDialog function
              const openFn = window.currentOpenEditDialog;
              if (openFn) {
                console.log(
                  "GraphRenderer: Opening edit dialog for:",
                  personName
                );
                openFn(personData);
              } else {
                console.warn(
                  "GraphRenderer: No edit dialog function available"
                );
              }
            } else {
              if (window.showNotification) {
                window.showNotification(
                  `Person "${personName}" ${currentTranslations.personNotFound || "not found"}`,
                  "error"
                );
              }
            }
          }
        } catch (error) {
          console.error("Error handling graph click:", error);
          if (window.showNotification) {
            window.showNotification(
              currentTranslations.errorOpening ||
                "Error opening person details",
              "error"
            );
          }
        }
      }

      // Set up event listeners
      graphContainer.addEventListener("click", handleGraphClick);

      // Set up global update handler
      window.updateGraph = function () {
        console.log("GraphRenderer: Update graph requested");
        renderGraph();
      };

      // Listen for data updates
      window.addEventListener("genealogy-data-updated", function () {
        console.log("GraphRenderer: Data updated, re-rendering graph");
        renderGraph();
      });

      // --- Listen for data changes from the dialog ---
      document.addEventListener("genealogy-data-changed", async (event) => {
        try {
          const saveDataToStorage = window.saveDataToStorage;
          const showNotification = window.showNotification;

          console.log("GraphRenderer: genealogy-data-changed event received");

          // Save to localStorage whenever data changes
          if (saveDataToStorage) saveDataToStorage();

          await renderGraph();

          if (showNotification) {
            showNotification(
              currentTranslations.graphUpdated || "Graph updated",
              "success"
            );
          }

          console.log(
            "genealogy-data-changed event, updated persons:",
            window.genealogyData?.persons
          );
        } catch (error) {
          console.error("Error updating graph:", error);
          if (window.showNotification) {
            window.showNotification(
              currentTranslations.errorUpdating || "Failed to update graph",
              "error"
            );
          }
        }
      });

      // --- Listen for tree changes ---
      document.addEventListener("genealogy-tree-changed", async (event) => {
        try {
          const updateTreeNameDisplay = window.updateTreeNameDisplay;
          const showNotification = window.showNotification;

          console.log("GraphRenderer: genealogy-tree-changed event received");
          console.log("GraphRenderer: Event detail:", event.detail);
          console.log(
            "GraphRenderer: Current genealogyData:",
            window.genealogyData
          );
          console.log(
            "GraphRenderer: Persons in current data:",
            window.genealogyData?.persons
          );

          // Reset zoom and pan state when switching trees for a fresh view
          const oldScale = currentScale;
          const oldTranslateX = currentTranslateX;
          const oldTranslateY = currentTranslateY;

          currentScale = 1;
          currentTranslateX = 0;
          currentTranslateY = 0;

          console.log(
            `GraphRenderer: tree-changed reset - scale: ${oldScale.toFixed(3)} to ${currentScale.toFixed(3)}, translate: (${oldTranslateX.toFixed(1)}, ${oldTranslateY.toFixed(1)}) to (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)})`
          );

          await renderGraph();

          if (updateTreeNameDisplay) updateTreeNameDisplay();

          const treeName = event.detail?.treeName || "Unknown";
          if (showNotification) {
            showNotification(
              currentTranslations.switchedToTree?.replace(
                "{treeName}",
                treeName
              ) || `Switched to tree: ${treeName}`,
              "success"
            );
          }

          console.log(
            "genealogy-tree-changed event, switched to tree:",
            treeName
          );
        } catch (error) {
          console.error("Error rendering graph after tree change:", error);
          if (window.showNotification) {
            window.showNotification(
              currentTranslations.errorUpdateAfterTreeChange ||
                "Failed to update graph after tree change",
              "error"
            );
          }
        }
      });

      // Initial render when system is ready
      renderGraph();
    }

    // Wait for genealogy system to be ready
    function waitForGenealogySystem() {
      console.log("GraphRenderer: Waiting for genealogy system to be ready");

      // Listen for the genealogy-system-ready event (with once: true to prevent multiple calls)
      window.addEventListener(
        "genealogy-system-ready",
        function () {
          console.log("GraphRenderer: Received genealogy-system-ready event");
          setupGraphFunctionality();
        },
        {once: true}
      );

      // Also check if it's already ready (in case event was missed)
      if (window.genealogyData && window.genealogySvgString) {
        console.log("GraphRenderer: Genealogy system already ready");
        setupGraphFunctionality();
        return;
      }

      // Fallback polling with timeout (but only if event hasn't fired)
      let pollCount = 0;
      const maxPolls = 150; // 30 seconds at 200ms intervals
      let hasSetup = false;

      const checkInterval = setInterval(() => {
        pollCount++;

        if (hasSetup) {
          clearInterval(checkInterval);
          return;
        }

        if (window.genealogyData && window.genealogySvgString) {
          clearInterval(checkInterval);
          hasSetup = true;
          console.log("GraphRenderer: Genealogy system ready via polling");
          setupGraphFunctionality();
        } else if (pollCount >= maxPolls) {
          clearInterval(checkInterval);

          // Check what's missing and show error
          const missingItems = [];
          if (!window.genealogyData) missingItems.push("genealogyData");
          if (!window.genealogySvgString)
            missingItems.push("genealogySvgString");

          console.error(
            `GraphRenderer: Timeout waiting for genealogy system. Missing: ${missingItems.join(", ")}`
          );

          if (graphPlaceholder) {
            graphPlaceholder.innerHTML = `
              <div style="text-align: center; color: #dc3545; padding: 20px;">
                <h3>${currentTranslations.initializationError || "Initialization Error"}</h3>
                <p>${currentTranslations.failedToLoad || "Failed to load the genealogy graph application."}</p>
                <p style="font-size: 12px; color: #6c757d; margin-top: 10px;">Missing: ${missingItems.join(", ")}</p>
                <button onclick="location.reload()" style="padding: 8px 16px; margin-top: 10px; border: 1px solid #dc3545; background: white; color: #dc3545; border-radius: 4px; cursor: pointer;">
                  ${currentTranslations.reloadPage || "Reload Page"}
                </button>
              </div>
            `;
          }
        }
      }, 200);
    }

    waitForGenealogySystem();

    return {
      updateTranslations: updateGraphRendererTranslations,
    };
  }

  // Initialize graph renderer when DOM is ready
  document.addEventListener("DOMContentLoaded", initializeGraphRenderer);
</script>
