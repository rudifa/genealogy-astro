---
import type {Language, Translations} from "../i18n/index";

interface Props {
  language: Language;
  translations: Translations;
}

const {language, translations} = Astro.props;
---

<div class='genealogy-graph'>
  <!-- Zoom controls -->
  <div class='zoom-controls'>
    <button id='zoom-in' class='zoom-btn' title='Zoom In (Larger)'>+</button>
    <button id='zoom-out' class='zoom-btn' title='Zoom Out (Smaller)'>−</button>
    <button
      id='zoom-fit'
      class='zoom-btn'
      title='Fit Tree to Screen (Best View)'>⌶</button
    >
    <button
      id='zoom-reset'
      class='zoom-btn'
      title='Reset to 1:1 Scale (Original Size)'>⌂</button
    >
  </div>

  <!-- SVG container with zoom/pan support -->
  <div id='graph-container' class='graph-container'>
    <div id='graph-placeholder' class='graph-placeholder'>
      <p>{translations.loadingGraph}</p>
    </div>
  </div>
</div>

<style>
  .genealogy-graph {
    flex: 1;
    display: flex;
    flex-direction: column;
    position: relative;
    background-color: #fafafa;
    overflow: hidden;
  }

  .zoom-controls {
    position: absolute;
    top: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 5px;
    z-index: 100;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    padding: 8px;
  }

  .zoom-btn {
    width: 36px;
    height: 36px;
    border: none;
    background: white;
    border-radius: 6px;
    font-size: 18px;
    font-weight: bold;
    color: #495057;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    user-select: none;
  }

  .zoom-btn:hover {
    background-color: #007acc;
    color: white;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }

  .zoom-btn:active {
    transform: translateY(0);
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  }

  .graph-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    cursor: grab;
  }

  .graph-container.panning {
    cursor: grabbing;
  }

  .graph-container .graph-content {
    position: absolute !important;
    top: 0;
    left: 0;
    transform-origin: 0 0 !important;
    transition: transform 0.2s ease;
  }

  .graph-container .graph-content.smooth-transition {
    transition: transform 0.3s ease;
  }

  .graph-placeholder {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: #6c757d;
    font-style: italic;
  }

  .graph-placeholder p {
    margin: 0;
    font-size: 16px;
  }

  /* SVG styling for better interaction */
  .graph-content svg {
    display: block;
    max-width: none;
    max-height: none;
  }

  /* Responsive zoom controls */
  @media (max-width: 768px) {
    .zoom-controls {
      top: 10px;
      right: 10px;
      padding: 6px;
    }

    .zoom-btn {
      width: 32px;
      height: 32px;
      font-size: 16px;
    }
  }
</style>

<script is:inline define:vars={{translations}}>
  // Graph Renderer functionality
  function initializeGraphRenderer() {
    console.log("GraphRenderer: Starting initialization");

    // Prevent multiple initializations with a single flag
    if (window.graphRendererInitialized) {
      console.log("GraphRenderer: Already initialized, skipping");
      return;
    }
    window.graphRendererInitialized = true;

    // Store current translations (will be updated by language changes)
    let currentTranslations = translations;

    // DOM elements are available immediately since they're in the same component
    const graphContainer = document.getElementById("graph-container");
    const graphPlaceholder = document.getElementById("graph-placeholder");
    const zoomInBtn = document.getElementById("zoom-in");
    const zoomOutBtn = document.getElementById("zoom-out");
    const zoomFitBtn = document.getElementById("zoom-fit");
    const zoomResetBtn = document.getElementById("zoom-reset");

    if (!graphContainer || !graphPlaceholder) {
      console.error("GraphRenderer: DOM elements not found in component");
      return;
    }

    console.log("GraphRenderer: DOM elements found, setting up functionality");

    // Update graph renderer translations
    function updateGraphRendererTranslations(newTranslations) {
      currentTranslations = newTranslations;

      // Update graph placeholder text
      const graphPlaceholder = document.querySelector("#graph-placeholder p");
      if (graphPlaceholder)
        graphPlaceholder.textContent = currentTranslations.loadingGraph;
    }

    // Listen for language changes
    window.addEventListener("languageChanged", function (event) {
      console.log("GraphRenderer: Language changed to", event.detail.language);
      updateGraphRendererTranslations(event.detail.translations);
    });

    // Initialize graph renderer events and rendering
    function setupGraphFunctionality() {
      console.log("GraphRenderer: Setting up graph functionality");

      // Zoom and pan state
      let currentScale = 1;
      let currentTranslateX = 0;
      let currentTranslateY = 0;
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragStartTranslateX = 0;
      let dragStartTranslateY = 0;
      let graphContent = null;
      let svgElement = null;

      // Zoom configuration
      const MIN_SCALE = 0.1;
      const MAX_SCALE = 5;
      const ZOOM_FACTOR = 1.2;

      // Update transform with current scale and translate values
      function updateTransform(smooth = false) {
        if (!graphContent) return;

        if (smooth) {
          graphContent.classList.add("smooth-transition");
          setTimeout(() => {
            if (graphContent)
              graphContent.classList.remove("smooth-transition");
          }, 300);
        }

        console.log(
          `GraphRenderer: updateTransform - scale: ${currentScale.toFixed(3)}, translate: (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)}), smooth: ${smooth}`
        );
        // Log units: scale(ratio), translate(px)

        // Apply CSS transform to .graph-content element
        // translate() uses pixels, scale() uses dimensionless ratio
        graphContent.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentScale})`;
        // Final CSS units: translate(px, px) scale(ratio)
      }

      // Zoom to a specific scale at a given point
      function zoomToPoint(newScale, clientX, clientY) {
        if (!graphContent || !svgElement) return;

        const oldScale = currentScale;
        const oldTranslateX = currentTranslateX;
        const oldTranslateY = currentTranslateY;

        newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

        const rect = graphContainer.getBoundingClientRect();
        const offsetX = clientX - rect.left;
        const offsetY = clientY - rect.top;

        // Calculate the point in the current coordinate system
        const currentPointX = (offsetX - currentTranslateX) / currentScale;
        const currentPointY = (offsetY - currentTranslateY) / currentScale;

        // Update scale
        currentScale = newScale;

        // Calculate new translate to keep the same point under the cursor
        currentTranslateX = offsetX - currentPointX * currentScale;
        currentTranslateY = offsetY - currentPointY * currentScale;

        console.log(
          `GraphRenderer: zoomToPoint - from scale: ${oldScale.toFixed(3)} to ${currentScale.toFixed(3)}, translate: (${oldTranslateX.toFixed(1)}, ${oldTranslateY.toFixed(1)}) to (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)}), cursor: (${clientX}, ${clientY})`
        );
        updateTransform();
      }

      // Fit the SVG to the container
      function fitToContainer() {
        if (!graphContent || !svgElement) return;

        const containerRect = graphContainer.getBoundingClientRect(); // Units: pixels (px) - viewport coordinates

        // Handle case where container is not visible yet
        if (containerRect.width === 0 || containerRect.height === 0) {
          console.log(
            `GraphRenderer: container not visible (${containerRect.width}x${containerRect.height}), retrying...`
          );
          setTimeout(() => fitToContainer(), 100);
          return;
        }

        const svgRect = svgElement.getBBox(); // Units: SVG user units (logical coordinates within SVG)

        console.log(
          "GraphRenderer 1-fitToContainer: containerRect px:",
          containerRect
        );
        console.log("GraphRenderer 2-fitToContainer: svgRect pt:", svgRect);

        if (svgRect.width === 0 || svgRect.height === 0) {
          console.log(
            `GraphRenderer: fitToContainer - SVG not ready (${svgRect.width}x${svgRect.height}), skipping`
          );
          return;
        }

        const oldScale = currentScale; // Units: dimensionless ratio (1.0 = 100%)
        const oldTranslateX = currentTranslateX; // Units: pixels (px) - CSS transform translate
        const oldTranslateY = currentTranslateY; // Units: pixels (px) - CSS transform translate

        // Use consistent dimensions for both scale calculation and centering
        // This ensures the scale and offset calculations are based on the same reference
        let svgWidth, svgHeight; // Units: pixels (px) - will be consistent reference

        if (svgElement.clientWidth > 0 && svgElement.clientHeight > 0) {
          // Use actual rendered dimensions for both scale and centering calculations
          svgWidth = svgElement.clientWidth; // Units: pixels (px) - DOM rendered size
          svgHeight = svgElement.clientHeight; // Units: pixels (px) - DOM rendered size
        } else {
          // Fallback to logical dimensions for both scale and centering
          svgWidth = svgRect.width; // Units: SVG user units (logical coordinates)
          svgHeight = svgRect.height; // Units: SVG user units (logical coordinates)
        }

        console.log(
          "GraphRenderer 3-fitToContainer: svgWidth x svgHeight px:",
          svgWidth,
          "x",
          svgHeight
        );

        // Add padding to ensure content doesn't touch edges
        const padding = 60; // Units: pixels (px) - visual padding around content
        const availableWidth = containerRect.width - padding; // Units: pixels (px)
        const availableHeight = containerRect.height - padding; // Units: pixels (px)

        console.log(
          "GraphRenderer 4-fitToContainer: availableWidth x availableHeight px:",
          availableWidth,
          "x",
          availableHeight
        );

        // Calculate scale factors to fit SVG within available container space
        const scaleX = availableWidth / svgWidth; // Units: dimensionless ratio (container_px / svg_px or svg_units)
        const scaleY = availableHeight / svgHeight; // Units: dimensionless ratio (container_px / svg_px or svg_units)

        console.log(
          "GraphRenderer 5-fitToContainer: scaleX x scaleY ratio:",
          scaleX,
          "x",
          scaleY
        );

        // Always fit to container, but don't zoom in beyond a reasonable max scale (0.8)
        // This ensures the graph doesn't fill the entire container
        const MAX_FIT_SCALE = 0.8; // Units: dimensionless ratio (max 80% zoom)
        currentScale = Math.min(scaleX, scaleY, MAX_FIT_SCALE); // Units: dimensionless ratio

        console.log(
          "GraphRenderer 6-fitToContainer: currentScale:",
          currentScale.toFixed(3)
        );

        // Calculate the actual scaled size using the SAME dimensions used for scale calculation
        const scaledWidth = svgWidth * currentScale; // Units: pixels (px) - final visual size
        const scaledHeight = svgHeight * currentScale; // Units: pixels (px) - final visual size

        console.log(
          `GraphRenderer 7-fitToContainer: scaledWidth x scaledHeight px: ${scaledWidth.toFixed(0)}x${scaledHeight.toFixed(0)}`
        );

        // Center the scaled SVG in the container
        // Account for any offset in the SVG's bounding box
        const svgOffsetX = svgRect.x || 0; // Units: SVG user units - offset of content within SVG coordinate space
        const svgOffsetY = svgRect.y || 0; // Units: SVG user units - offset of content within SVG coordinate space

        console.log(
          `GraphRenderer 8-fitToContainer: svgOffsetX x svgOffsetY px: ${svgOffsetX.toFixed(0)}x${svgOffsetY.toFixed(0)}`
        );

        // Center the actual visual content within the full container
        // Use the same dimensions that were used for scaling to ensure consistency
        currentTranslateX =
          (containerRect.width - scaledWidth) / 2 - svgOffsetX * currentScale;
        // Units breakdown: (pixels - pixels) / 2 - (svg_units * ratio) = pixels
        currentTranslateY =
          (containerRect.height - scaledHeight) / 2 - svgOffsetY * currentScale;
        // Units breakdown: (pixels - pixels) / 2 - (svg_units * ratio) = pixels

        console.log(
          `GraphRenderer 9-fitToContainer: currentTranslateX x currentTranslateY px: ${currentTranslateX.toFixed(1)}x${currentTranslateY.toFixed(1)}`
        );
        console.log(
          `GraphRenderer: fitToContainer - container: ${containerRect.width.toFixed(0)}x${containerRect.height.toFixed(0)}, SVG getBBox: ${svgRect.width.toFixed(0)}x${svgRect.height.toFixed(0)} at (${svgRect.x.toFixed(0)}, ${svgRect.y.toFixed(0)}), SVG client: ${svgElement.clientWidth}x${svgElement.clientHeight}, using: ${svgWidth.toFixed(0)}x${svgHeight.toFixed(0)}, available: ${availableWidth.toFixed(0)}x${availableHeight.toFixed(0)}, scaleX: ${scaleX.toFixed(3)}, scaleY: ${scaleY.toFixed(3)}, scale: ${oldScale.toFixed(3)} to ${currentScale.toFixed(3)}, scaled size: ${scaledWidth.toFixed(0)}x${scaledHeight.toFixed(0)}, offset: (${svgOffsetX.toFixed(0)}, ${svgOffsetY.toFixed(0)}), translate: (${oldTranslateX.toFixed(1)}, ${oldTranslateY.toFixed(1)}) to (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)})`
        );
        // Log units: container(px), getBBox(svg_units), client(px), using(px or svg_units), available(px),
        // scale(ratio), scaled_size(px), offset(svg_units), translate(px)

        // Additional logging to verify centering calculation
        console.log(
          `GraphRenderer: centering - container center: ${((containerRect.width - scaledWidth) / 2).toFixed(1)}, offset adjustment: ${(-svgOffsetX * currentScale).toFixed(1)}, final translateX: ${currentTranslateX.toFixed(1)}`
        );
        // Log units: container_center(px), offset_adjustment(px), final_translateX(px)

        updateTransform(true); // Apply CSS transform: translate(px, px) scale(ratio)
      }

      // Reset zoom and position to 1:1 scale, centered
      function resetZoom() {
        if (!graphContent || !svgElement) return;

        const oldScale = currentScale; // Units: dimensionless ratio
        const oldTranslateX = currentTranslateX; // Units: pixels (px)
        const oldTranslateY = currentTranslateY; // Units: pixels (px)

        // Reset to 1:1 scale
        currentScale = 1; // Units: dimensionless ratio (1.0 = 100%, no scaling)

        // Center the SVG at 1:1 scale using logical dimensions for centering
        const containerRect = graphContainer.getBoundingClientRect(); // Units: pixels (px)
        const svgRect = svgElement.getBBox(); // Units: SVG user units (logical coordinates)
        let svgWidth, svgHeight; // Units: SVG user units (will use logical dimensions)

        // Use logical dimensions for centering at 1:1 scale
        svgWidth = svgRect.width; // Units: SVG user units
        svgHeight = svgRect.height; // Units: SVG user units

        // Get the SVG's offset from its bounding box
        const svgOffsetX = svgRect.x || 0; // Units: SVG user units
        const svgOffsetY = svgRect.y || 0; // Units: SVG user units

        // Center at 1:1 scale using the same formula as fitToContainer
        // The translate formula is:
        // (containerRect.width - svgWidth) / 2 - svgOffsetX
        // This ensures consistent behavior between reset and fit-to-screen
        currentTranslateX = (containerRect.width - svgWidth) / 2 - svgOffsetX;
        // Units breakdown: (pixels - svg_units) / 2 - svg_units = pixels (at 1:1 scale, svg_units ≈ pixels)
        currentTranslateY = (containerRect.height - svgHeight) / 2 - svgOffsetY;
        // Units breakdown: (pixels - svg_units) / 2 - svg_units = pixels (at 1:1 scale, svg_units ≈ pixels)

        console.log(
          `GraphRenderer: resetZoom - scale: ${oldScale.toFixed(3)} to ${currentScale.toFixed(3)}, translate: (${oldTranslateX.toFixed(1)}, ${oldTranslateY.toFixed(1)}) to (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)}), centered at 1:1, SVG offset: (${svgOffsetX.toFixed(0)}, ${svgOffsetY.toFixed(0)})`
        );
        // Log units: scale(ratio), translate(px), SVG_offset(svg_units)

        updateTransform(true); // Apply CSS transform: translate(px, px) scale(ratio)
      }

      // Set up zoom controls
      if (zoomInBtn) {
        zoomInBtn.addEventListener("click", () => {
          const rect = graphContainer.getBoundingClientRect();
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          zoomToPoint(currentScale * ZOOM_FACTOR, centerX, centerY);
        });
      }

      if (zoomOutBtn) {
        zoomOutBtn.addEventListener("click", () => {
          const rect = graphContainer.getBoundingClientRect();
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          zoomToPoint(currentScale / ZOOM_FACTOR, centerX, centerY);
        });
      }

      if (zoomFitBtn) {
        zoomFitBtn.addEventListener("click", fitToContainer);
      }

      if (zoomResetBtn) {
        zoomResetBtn.addEventListener("click", resetZoom);
      }

      // Mouse wheel zoom
      graphContainer.addEventListener("wheel", (event) => {
        event.preventDefault();

        const zoomIn = event.deltaY < 0;
        const newScale = zoomIn
          ? currentScale * ZOOM_FACTOR
          : currentScale / ZOOM_FACTOR;

        zoomToPoint(
          newScale,
          event.clientX - graphContainer.getBoundingClientRect().left,
          event.clientY - graphContainer.getBoundingClientRect().top
        );
      });

      // Mouse drag panning
      graphContainer.addEventListener("mousedown", (event) => {
        if (event.button !== 0) return; // Only left mouse button

        isDragging = true;
        dragStartX = event.clientX;
        dragStartY = event.clientY;
        dragStartTranslateX = currentTranslateX;
        dragStartTranslateY = currentTranslateY;

        graphContainer.classList.add("panning");
        event.preventDefault();
      });

      document.addEventListener("mousemove", (event) => {
        if (!isDragging) return;

        const deltaX = event.clientX - dragStartX;
        const deltaY = event.clientY - dragStartY;

        const oldTranslateX = currentTranslateX;
        const oldTranslateY = currentTranslateY;

        currentTranslateX = dragStartTranslateX + deltaX;
        currentTranslateY = dragStartTranslateY + deltaY;

        // Only log every 10px of movement to avoid spam
        if (Math.abs(deltaX) % 10 < 2 && Math.abs(deltaY) % 10 < 2) {
          console.log(
            `GraphRenderer: mouseDrag - delta: (${deltaX.toFixed(0)}, ${deltaY.toFixed(0)}), translate: (${oldTranslateX.toFixed(1)}, ${oldTranslateY.toFixed(1)}) to (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)})`
          );
        }

        updateTransform();
      });

      document.addEventListener("mouseup", () => {
        if (isDragging) {
          isDragging = false;
          graphContainer.classList.remove("panning");
        }
      });

      // Window resize handler to maintain proper fit
      let resizeTimeout;
      function handleResize() {
        // Debounce resize events to avoid excessive calls
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if (graphContent && svgElement) {
            console.log(
              `GraphRenderer: handleResize - triggering fitToContainer`
            );
            // Re-fit the graph to the new container size
            fitToContainer();
          }
        }, 150);
      }

      // Listen for window resize events
      window.addEventListener("resize", handleResize);

      // Store cleanup function for this component instance
      window.graphRendererCleanup = function () {
        window.removeEventListener("resize", handleResize);
        clearTimeout(resizeTimeout);
      };

      // Touch support for mobile
      let touchStartDistance = 0;
      let touchStartScale = 1;

      graphContainer.addEventListener("touchstart", (event) => {
        if (event.touches.length === 2) {
          // Two finger pinch
          const touch1 = event.touches[0];
          const touch2 = event.touches[1];
          touchStartDistance = Math.hypot(
            touch1.clientX - touch2.clientX,
            touch1.clientY - touch2.clientY
          );
          touchStartScale = currentScale;
          event.preventDefault();
        } else if (event.touches.length === 1) {
          // Single finger drag
          const touch = event.touches[0];
          isDragging = true;
          dragStartX = touch.clientX;
          dragStartY = touch.clientY;
          dragStartTranslateX = currentTranslateX;
          dragStartTranslateY = currentTranslateY;
          event.preventDefault();
        }
      });

      graphContainer.addEventListener("touchmove", (event) => {
        if (event.touches.length === 2) {
          // Two finger pinch zoom
          const touch1 = event.touches[0];
          const touch2 = event.touches[1];
          const currentDistance = Math.hypot(
            touch1.clientX - touch2.clientX,
            touch1.clientY - touch2.clientY
          );

          if (touchStartDistance > 0) {
            const scaleFactor = currentDistance / touchStartDistance;
            const newScale = touchStartScale * scaleFactor;

            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;
            const rect = graphContainer.getBoundingClientRect();

            zoomToPoint(newScale, centerX - rect.left, centerY - rect.top);
          }
          event.preventDefault();
        } else if (event.touches.length === 1 && isDragging) {
          // Single finger pan
          const touch = event.touches[0];
          const deltaX = touch.clientX - dragStartX;
          const deltaY = touch.clientY - dragStartY;

          currentTranslateX = dragStartTranslateX + deltaX;
          currentTranslateY = dragStartTranslateY + deltaY;

          updateTransform();
          event.preventDefault();
        }
      });

      graphContainer.addEventListener("touchend", () => {
        isDragging = false;
        touchStartDistance = 0;
      });

      // --- Function to render the graph ---
      async function renderGraph() {
        const genealogyData = window.genealogyData;
        const genealogySvgString = window.genealogySvgString;
        const showNotification = window.showNotification;
        const setLoadingState = window.setLoadingState;
        const isRendering = window.genealogyIsRendering;

        console.log(
          "GraphRenderer: renderGraph called at",
          new Date().toISOString()
        );
        console.log("GraphRenderer: genealogyData:", genealogyData);
        console.log(
          "GraphRenderer: persons count:",
          genealogyData?.persons?.length
        );

        if (
          !graphContainer ||
          isRendering ||
          !genealogyData ||
          !genealogySvgString
        ) {
          console.warn(
            "GraphRenderer: Missing dependencies for rendering - EARLY EXIT"
          );
          console.warn("GraphRenderer: graphContainer:", !!graphContainer);
          console.warn("GraphRenderer: isRendering:", isRendering);
          console.warn("GraphRenderer: genealogyData:", !!genealogyData);
          console.warn(
            "GraphRenderer: genealogySvgString:",
            !!genealogySvgString
          );
          return;
        }

        try {
          console.log("GraphRenderer: Entering try block");
          if (setLoadingState) setLoadingState(true);
          window.genealogyIsRendering = true;

          // Hide placeholder if it exists
          if (graphPlaceholder) {
            graphPlaceholder.style.display = "none";
          }

          console.log(
            "GraphRenderer: Calling genealogySvgString with data:",
            genealogyData
          );
          const newSvgString = await genealogySvgString(genealogyData);
          console.log(
            "GraphRenderer 1-renderGraph: Received SVG string length:",
            newSvgString?.length,
            "First 500 characters:",
            newSvgString?.slice(0, 500)
          );

          // Create or update graph content container
          if (!graphContent) {
            graphContent = document.createElement("div");
            graphContent.className = "graph-content";
            graphContainer.appendChild(graphContent);

            // Force the positioning styles programmatically to ensure they take effect
            graphContent.style.position = "absolute";
            graphContent.style.top = "0";
            graphContent.style.left = "0";
            graphContent.style.transformOrigin = "0 0";
          }

          graphContent.innerHTML = newSvgString;

          // Get reference to the SVG element
          svgElement = graphContent.querySelector("svg");
          if (svgElement) {
            // Log SVG attributes before modification
            console.log(
              "GraphRenderer 2-renderGraph: SVG before modification:",
              {
                width: svgElement.getAttribute("width"),
                height: svgElement.getAttribute("height"),
                viewBox: svgElement.getAttribute("viewBox"),
                style: svgElement.getAttribute("style"),
              }
            );

            // Instead of removing width/height, preserve the original size
            // and let CSS handle the scaling
            const originalWidth = svgElement.getAttribute("width"); // Units: typically "pt" (points)
            const originalHeight = svgElement.getAttribute("height"); // Units: typically "pt" (points)

            if (originalWidth && originalHeight) {
              const widthValue = parseFloat(originalWidth); // Units: points (pt)
              const heightValue = parseFloat(originalHeight); // Units: points (pt)

              // Convert pt to px: 1pt = 4/3 px
              const widthPx = Math.round((widthValue * 4) / 3); // Units: pixels (px)
              const heightPx = Math.round((heightValue * 4) / 3); // Units: pixels (px)

              // Set explicit pixel dimensions on the SVG element's style
              // This establishes the rendered size in the DOM
              svgElement.style.width = widthPx + "px"; // Units: pixels (px) - DOM rendering size
              svgElement.style.height = heightPx + "px"; // Units: pixels (px) - DOM rendering size

              console.log(
                `GraphRenderer 3-renderGraph: Converted SVG size from ${widthValue}pt x ${heightValue}pt to ${widthPx}px x ${heightPx}px`
              );

              // Remove the pt-based attributes to avoid conflicts
              svgElement.removeAttribute("width");
              svgElement.removeAttribute("height");
            }

            // Log SVG attributes after modification
            console.log(
              "GraphRenderer 3-renderGraph: svgElement after modification:",
              {
                getBBox: svgElement.getBBox(), // Units: SVG user units (logical coordinates)
                clientWidth: svgElement.clientWidth, // Units: pixels (px) - rendered DOM size
                clientHeight: svgElement.clientHeight, // Units: pixels (px) - rendered DOM size
                offsetWidth: svgElement.offsetWidth, // Units: pixels (px) - rendered DOM size including borders
                offsetHeight: svgElement.offsetHeight, // Units: pixels (px) - rendered DOM size including borders
                styleWidth: svgElement.style.width, // Units: string with units (e.g., "400px")
                styleHeight: svgElement.style.height, // Units: string with units (e.g., "300px")
              }
            );

            // Auto-fit to container on first render or when tree changes
            setTimeout(() => {
              console.log("GraphRenderer: Graph will be rendered");

              fitToContainer();
            }, 100);
          }

          // Show success notification for significant changes
          if (genealogyData.persons.length === 0 && showNotification) {
            showNotification(
              currentTranslations.graphCleared || "Graph cleared",
              "info"
            );
          }
        } catch (error) {
          console.error("GraphRenderer: Error rendering graph:", error);
          if (graphPlaceholder) {
            graphPlaceholder.style.display = "block";
            const p = graphPlaceholder.querySelector("p");
            if (p) {
              p.textContent =
                currentTranslations.renderError ||
                "Error rendering graph. Please try again.";
              p.style.color = "#dc3545";
            }
          }
        } finally {
          window.genealogyIsRendering = false;
          if (setLoadingState) setLoadingState(false);
        }
      }

      // --- Graph interaction handler ---
      function handleGraphClick(event) {
        try {
          const targetLink = event.target.closest("a");

          if (!targetLink) {
            return;
          }

          const url =
            targetLink.getAttribute("xlink:href") ||
            targetLink.getAttribute("href");

          if (url && url.startsWith("person:")) {
            event.preventDefault();

            const personName = decodeURIComponent(
              url.substring("person:".length)
            );

            console.log("GraphRenderer: Person clicked:", personName);

            const genealogyData = window.genealogyData;
            if (!genealogyData) {
              console.warn("GraphRenderer: No genealogy data available");
              return;
            }

            const personData = genealogyData.persons.find(
              (p) => p.name === personName
            );

            if (personData) {
              // Use the current openEditDialog function
              const openFn = window.currentOpenEditDialog;
              if (openFn) {
                console.log(
                  "GraphRenderer: Opening edit dialog for:",
                  personName
                );
                openFn(personData);
              } else {
                console.warn(
                  "GraphRenderer: No edit dialog function available"
                );
              }
            } else {
              if (window.showNotification) {
                window.showNotification(
                  `Person "${personName}" ${currentTranslations.personNotFound || "not found"}`,
                  "error"
                );
              }
            }
          }
        } catch (error) {
          console.error("Error handling graph click:", error);
          if (window.showNotification) {
            window.showNotification(
              currentTranslations.errorOpening ||
                "Error opening person details",
              "error"
            );
          }
        }
      }

      // Set up event listeners
      graphContainer.addEventListener("click", handleGraphClick);

      // Set up global update handler
      window.updateGraph = function () {
        console.log(
          "GraphRenderer: Update graph requested via window.updateGraph"
        );
        renderGraph();
      };

      // Listen for data updates
      window.addEventListener("genealogy-data-updated", function () {
        console.log(
          "GraphRenderer: Data updated, re-rendering graph via event"
        );
        renderGraph();
      });

      // --- Listen for data changes from the dialog ---
      document.addEventListener("genealogy-data-changed", async (event) => {
        try {
          const saveDataToStorage = window.saveDataToStorage;
          const showNotification = window.showNotification;

          console.log("GraphRenderer: genealogy-data-changed event received");

          // Save to localStorage whenever data changes
          if (saveDataToStorage) saveDataToStorage();

          await renderGraph();

          if (showNotification) {
            showNotification(
              currentTranslations.graphUpdated || "Graph updated",
              "success"
            );
          }

          console.log(
            "genealogy-data-changed event, updated persons:",
            window.genealogyData?.persons
          );
        } catch (error) {
          console.error("Error updating graph:", error);
          if (window.showNotification) {
            window.showNotification(
              currentTranslations.errorUpdating || "Failed to update graph",
              "error"
            );
          }
        }
      });

      // --- Listen for tree changes ---
      document.addEventListener("genealogy-tree-changed", async (event) => {
        try {
          const updateTreeNameDisplay = window.updateTreeNameDisplay;
          const showNotification = window.showNotification;

          console.log("GraphRenderer: genealogy-tree-changed event received");
          console.log("GraphRenderer: Event detail:", event.detail);
          console.log(
            "GraphRenderer: Current genealogyData:",
            window.genealogyData
          );
          console.log(
            "GraphRenderer: Persons in current data:",
            window.genealogyData?.persons
          );

          // Reset zoom and pan state when switching trees for a fresh view
          const oldScale = currentScale;
          const oldTranslateX = currentTranslateX;
          const oldTranslateY = currentTranslateY;

          currentScale = 1;
          currentTranslateX = 0;
          currentTranslateY = 0;

          console.log(
            `GraphRenderer: tree-changed reset - scale: ${oldScale.toFixed(3)} to ${currentScale.toFixed(3)}, translate: (${oldTranslateX.toFixed(1)}, ${oldTranslateY.toFixed(1)}) to (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)})`
          );

          await renderGraph();

          if (updateTreeNameDisplay) updateTreeNameDisplay();

          const treeName = event.detail?.treeName || "Unknown";
          if (showNotification) {
            showNotification(
              currentTranslations.switchedToTree?.replace(
                "{treeName}",
                treeName
              ) || `Switched to tree: ${treeName}`,
              "success"
            );
          }

          console.log(
            "genealogy-tree-changed event, switched to tree:",
            treeName
          );
        } catch (error) {
          console.error("Error rendering graph after tree change:", error);
          if (window.showNotification) {
            window.showNotification(
              currentTranslations.errorUpdateAfterTreeChange ||
                "Failed to update graph after tree change",
              "error"
            );
          }
        }
      });

      // Expose diagnostic tools for debugging (moved inside scope to access variables)
      window.checkSvgMargins = function () {
        if (!svgElement || !graphContent || !graphContainer) {
          console.error("SVG elements not available");
          return;
        }

        const containerRect = graphContainer.getBoundingClientRect();
        const svgRect = svgElement.getBBox();
        const scaledWidth = svgRect.width * currentScale;
        const scaledHeight = svgRect.height * currentScale;

        const leftMargin = currentTranslateX;
        const rightMargin =
          containerRect.width - (scaledWidth + currentTranslateX);
        const topMargin = currentTranslateY;
        const bottomMargin =
          containerRect.height - (scaledHeight + currentTranslateY);

        console.log(
          `SVG Margins and Scale Analysis:
          - Current Scale: ${currentScale.toFixed(3)}
          - Container Size: ${containerRect.width.toFixed(0)}x${containerRect.height.toFixed(0)}
          - SVG Size (getBBox): ${svgRect.width.toFixed(0)}x${svgRect.height.toFixed(0)} at (${svgRect.x.toFixed(0)}, ${svgRect.y.toFixed(0)})
          - SVG Size (client): ${svgElement.clientWidth}x${svgElement.clientHeight}
          - Scaled Size: ${scaledWidth.toFixed(0)}x${scaledHeight.toFixed(0)}
          - Current Translate: (${currentTranslateX.toFixed(1)}, ${currentTranslateY.toFixed(1)})
          - Margins: Left=${leftMargin.toFixed(1)}, Right=${rightMargin.toFixed(1)}, Top=${topMargin.toFixed(1)}, Bottom=${bottomMargin.toFixed(1)}
          - Centering Check: Left-Right diff=${(leftMargin - rightMargin).toFixed(1)}, Top-Bottom diff=${(topMargin - bottomMargin).toFixed(1)}
          - Ideal Translate X for perfect centering: ${((containerRect.width - scaledWidth) / 2 - svgRect.x * currentScale).toFixed(1)}`
        );

        return {
          scale: currentScale,
          container: {width: containerRect.width, height: containerRect.height},
          svgBBox: {
            width: svgRect.width,
            height: svgRect.height,
            x: svgRect.x,
            y: svgRect.y,
          },
          svgClient: {
            width: svgElement.clientWidth,
            height: svgElement.clientHeight,
          },
          scaledSize: {width: scaledWidth, height: scaledHeight},
          translate: {x: currentTranslateX, y: currentTranslateY},
          margins: {
            left: leftMargin,
            right: rightMargin,
            top: topMargin,
            bottom: bottomMargin,
          },
          centeringCheck: {
            xDiff: leftMargin - rightMargin,
            yDiff: topMargin - bottomMargin,
            idealTranslateX:
              (containerRect.width - scaledWidth) / 2 -
              svgRect.x * currentScale,
          },
        };
      };

      // Advanced debugging function to trace the 68x58 pixel offset
      window.debugVisualOffset = function () {
        if (!svgElement || !graphContent || !graphContainer) {
          console.error("SVG elements not available for offset debugging");
          return;
        }

        console.log("=== VISUAL OFFSET DEBUGGING ===");

        // 1. Container measurements (pixels in viewport)
        const containerRect = graphContainer.getBoundingClientRect();
        console.log("1. Container getBoundingClientRect (viewport px):", {
          x: containerRect.x,
          y: containerRect.y,
          width: containerRect.width,
          height: containerRect.height,
          top: containerRect.top,
          left: containerRect.left,
          right: containerRect.right,
          bottom: containerRect.bottom,
        });

        // 2. Graph content div measurements (positioned element)
        const contentRect = graphContent.getBoundingClientRect();
        console.log("2. GraphContent getBoundingClientRect (viewport px):", {
          x: contentRect.x,
          y: contentRect.y,
          width: contentRect.width,
          height: contentRect.height,
          top: contentRect.top,
          left: contentRect.left,
          right: contentRect.right,
          bottom: contentRect.bottom,
        });

        // 3. SVG element measurements (DOM element)
        const svgRect = svgElement.getBoundingClientRect();
        console.log("3. SVG getBoundingClientRect (viewport px):", {
          x: svgRect.x,
          y: svgRect.y,
          width: svgRect.width,
          height: svgRect.height,
          top: svgRect.top,
          left: svgRect.left,
          right: svgRect.right,
          bottom: svgRect.bottom,
        });

        // 4. SVG logical bounding box (SVG user units)
        const svgBBox = svgElement.getBBox();
        console.log("4. SVG getBBox (SVG user units):", {
          x: svgBBox.x,
          y: svgBBox.y,
          width: svgBBox.width,
          height: svgBBox.height,
        });

        // 5. Current transform state
        console.log("5. Current Transform State:", {
          scale: currentScale,
          translateX: currentTranslateX,
          translateY: currentTranslateY,
          appliedTransform: graphContent.style.transform,
        });

        // 6. Calculate the visual offset between container and SVG
        const offsetX = svgRect.left - containerRect.left;
        const offsetY = svgRect.top - containerRect.top;
        console.log("6. Visual Offset (SVG - Container, px):", {
          offsetX: offsetX.toFixed(1),
          offsetY: offsetY.toFixed(1),
          description: `SVG appears ${offsetX.toFixed(1)}px right and ${offsetY.toFixed(1)}px down from container top-left`,
        });

        // 7. CSS computed styles for all elements
        const containerStyles = window.getComputedStyle(graphContainer);
        const contentStyles = window.getComputedStyle(graphContent);
        const svgStyles = window.getComputedStyle(svgElement);

        console.log("7a. Container computed styles (relevant):", {
          position: containerStyles.position,
          padding: `${containerStyles.paddingTop} ${containerStyles.paddingRight} ${containerStyles.paddingBottom} ${containerStyles.paddingLeft}`,
          margin: `${containerStyles.marginTop} ${containerStyles.marginRight} ${containerStyles.marginBottom} ${containerStyles.marginLeft}`,
          border: `${containerStyles.borderTopWidth} ${containerStyles.borderRightWidth} ${containerStyles.borderBottomWidth} ${containerStyles.borderLeftWidth}`,
          overflow: containerStyles.overflow,
        });

        console.log("7b. GraphContent computed styles (relevant):", {
          position: contentStyles.position,
          top: contentStyles.top,
          left: contentStyles.left,
          transform: contentStyles.transform,
          transformOrigin: contentStyles.transformOrigin,
          padding: `${contentStyles.paddingTop} ${contentStyles.paddingRight} ${contentStyles.paddingBottom} ${contentStyles.paddingLeft}`,
          margin: `${contentStyles.marginTop} ${contentStyles.marginRight} ${contentStyles.marginBottom} ${contentStyles.marginLeft}`,
          className: graphContent.className,
          classList: Array.from(graphContent.classList),
          elementId: graphContent.id,
        });

        console.log("7c. SVG computed styles (relevant):", {
          display: svgStyles.display,
          width: svgStyles.width,
          height: svgStyles.height,
          maxWidth: svgStyles.maxWidth,
          maxHeight: svgStyles.maxHeight,
          padding: `${svgStyles.paddingTop} ${svgStyles.paddingRight} ${svgStyles.paddingBottom} ${svgStyles.paddingLeft}`,
          margin: `${svgStyles.marginTop} ${svgStyles.marginRight} ${svgStyles.marginBottom} ${svgStyles.marginLeft}`,
          transform: svgStyles.transform,
        });

        // 8. SVG viewBox analysis (if present)
        const viewBox = svgElement.getAttribute("viewBox");
        if (viewBox) {
          const [vbX, vbY, vbWidth, vbHeight] = viewBox.split(" ").map(Number);
          console.log("8. SVG viewBox analysis:", {
            viewBox: viewBox,
            parsed: {x: vbX, y: vbY, width: vbWidth, height: vbHeight},
            bboxVsViewbox: {
              xDiff: svgBBox.x - vbX,
              yDiff: svgBBox.y - vbY,
              widthDiff: svgBBox.width - vbWidth,
              heightDiff: svgBBox.height - vbHeight,
            },
          });
        } else {
          console.log("8. SVG viewBox: none set");
        }

        // 9. Check for any transforms on parent elements
        let element = graphContainer.parentElement;
        let level = 0;
        console.log("9. Parent element transforms:");
        while (element && level < 5) {
          const styles = window.getComputedStyle(element);
          if (
            styles.transform !== "none" ||
            styles.position === "relative" ||
            styles.position === "absolute"
          ) {
            console.log(
              `  Level ${level} (${element.tagName}.${element.className}):`,
              {
                transform: styles.transform,
                position: styles.position,
                top: styles.top,
                left: styles.left,
              }
            );
          }
          element = element.parentElement;
          level++;
        }

        // 10. Calculate expected vs actual positions
        const expectedSvgLeft = containerRect.left + currentTranslateX;
        const expectedSvgTop = containerRect.top + currentTranslateY;
        const actualSvgLeft = svgRect.left;
        const actualSvgTop = svgRect.top;

        console.log("10. Expected vs Actual SVG Position:", {
          expected: {left: expectedSvgLeft, top: expectedSvgTop},
          actual: {left: actualSvgLeft, top: actualSvgTop},
          unexplainedOffset: {
            x: actualSvgLeft - expectedSvgLeft,
            y: actualSvgTop - expectedSvgTop,
          },
        });

        // 11. Return comprehensive data for further analysis
        return {
          container: containerRect,
          graphContent: contentRect,
          svg: svgRect,
          svgBBox: svgBBox,
          visualOffset: {x: offsetX, y: offsetY},
          transform: {
            scale: currentScale,
            translateX: currentTranslateX,
            translateY: currentTranslateY,
          },
          unexplainedOffset: {
            x: actualSvgLeft - expectedSvgLeft,
            y: actualSvgTop - expectedSvgTop,
          },
          viewBox: viewBox,
        };
      };

      // Initial render when system is ready
      console.log("GraphRenderer: About to call renderGraph() initially");
      renderGraph();
    }

    // Wait for genealogy system to be ready
    function waitForGenealogySystem() {
      console.log("GraphRenderer: Waiting for genealogy system to be ready");

      // Listen for the genealogy-system-ready event (with once: true to prevent multiple calls)
      window.addEventListener(
        "genealogy-system-ready",
        function () {
          console.log("GraphRenderer: Received genealogy-system-ready event");
          setupGraphFunctionality();
        },
        {once: true}
      );

      // Also check if it's already ready (in case event was missed)
      if (window.genealogyData && window.genealogySvgString) {
        console.log("GraphRenderer: Genealogy system already ready");
        setupGraphFunctionality();
        return;
      }

      // Fallback polling with timeout (but only if event hasn't fired)
      let pollCount = 0;
      const maxPolls = 150; // 30 seconds at 200ms intervals
      let hasSetup = false;

      const checkInterval = setInterval(() => {
        pollCount++;

        if (hasSetup) {
          clearInterval(checkInterval);
          return;
        }

        if (window.genealogyData && window.genealogySvgString) {
          clearInterval(checkInterval);
          hasSetup = true;
          console.log("GraphRenderer: Genealogy system ready via polling");
          setupGraphFunctionality();
        } else if (pollCount >= maxPolls) {
          clearInterval(checkInterval);

          // Check what's missing and show error
          const missingItems = [];
          if (!window.genealogyData) missingItems.push("genealogyData");
          if (!window.genealogySvgString)
            missingItems.push("genealogySvgString");

          console.error(
            `GraphRenderer: Timeout waiting for genealogy system. Missing: ${missingItems.join(", ")}`
          );

          if (graphPlaceholder) {
            graphPlaceholder.innerHTML = `
              <div style="text-align: center; color: #dc3545; padding: 20px;">
                <h3>${currentTranslations.initializationError || "Initialization Error"}</h3>
                <p>${currentTranslations.failedToLoad || "Failed to load the genealogy graph application."}</p>
                <p style="font-size: 12px; color: #6c757d; margin-top: 10px;">Missing: ${missingItems.join(", ")}</p>
                <button onclick="location.reload()" style="padding: 8px 16px; margin-top: 10px; border: 1px solid #dc3545; background: white; color: #dc3545; border-radius: 4px; cursor: pointer;">
                  ${currentTranslations.reloadPage || "Reload Page"}
                </button>
              </div>
            `;
          }
        }
      }, 200);
    }

    waitForGenealogySystem();

    return {
      updateTranslations: updateGraphRendererTranslations,
    };
  }

  // Initialize graph renderer when DOM is ready
  document.addEventListener("DOMContentLoaded", initializeGraphRenderer);
</script>
